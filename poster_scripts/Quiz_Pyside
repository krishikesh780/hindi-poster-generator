import os
import random
import pandas as pd
import json
from PIL import Image, ImageDraw, ImageFont, ImageColor
import cv2
import zipfile
import io
from PySide6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QGroupBox, QComboBox, 
                               QSlider, QCheckBox, QPushButton, QLabel, QProgressBar, QFileDialog, 
                               QScrollArea, QMessageBox, QColorDialog, QTextEdit, QTabWidget, QDialog, 
                               QGridLayout, QSizePolicy)
from PySide6.QtCore import Qt, QThread, Signal, QPropertyAnimation, QEasingCurve
from PySide6.QtGui import QImage, QPixmap, QPalette, QColor, QFont
from itertools import cycle, islice

# --- BASE DIR ---
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# --- CONFIG LOAD ---
try:
    with open(os.path.join(BASE_DIR, "data.json"), "r", encoding="utf-8") as f:
        CONFIG = json.load(f)
except Exception as e:
    print(f"Failed to load config: {e}")
    exit()

# --- EXTRACT CONFIG DATA ---
FONT_OPTIONS = {name: os.path.join(BASE_DIR, path) for name, path in CONFIG["font_options"].items()}
PLATFORM_DIMENSIONS = {name: tuple(dim) for name, dim in CONFIG["platform_dimensions"].items()}
defaults = CONFIG["defaults"]
watermark_defaults = defaults["watermark"]
labels = CONFIG["labels"]

# --- PATH SETUP ---
FONTS_DIR = os.path.join(BASE_DIR, '..', 'fonts')
WALLPAPER_FOLDER = os.path.join(BASE_DIR, '..', 'input', 'Question-Wallpapers')

# --- HELPER FUNCTIONS ---
def wrap_text(text, font, max_width):
    lines = []
    for paragraph in text.split('\n'):
        words = paragraph.split()
        line = ""
        for word in words:
            test_line = line + word + " "
            if font.getlength(test_line) <= max_width:
                line = test_line
            else:
                lines.append(line.strip())
                line = word + " "
        if line:
            lines.append(line.strip())
        lines.append("")
    return lines

def draw_centered_text(draw_obj, lines, font, image_width, y_pos, color, bg_color):
    for line in lines:
        text_width = font.getlength(line)
        text_height = font.getbbox(line)[3]
        x_pos = (image_width - text_width) / 2
        if bg_color:
            draw_obj.rectangle(
                [x_pos - 10, y_pos - 5, x_pos + text_width + 10, y_pos + text_height + 5],
                fill=bg_color
            )
        draw_obj.text((x_pos, y_pos), line, font=font, fill=color)
        y_pos += text_height + 10
    return y_pos

def add_watermark(image, text, font_path, font_size, color, rotation_angle, opacity_percent):
    watermark = Image.new("RGBA", image.size, (0, 0, 0, 0))
    draw = ImageDraw.Draw(watermark)
    font = ImageFont.truetype(font_path, font_size)
    opacity = int(255 * (opacity_percent / 100))
    fill_color = ImageColor.getrgb(color) + (opacity,)
    spacing_x = int(font.getlength(text) * 1.5)
    spacing_y = int(font_size * 2)

    for y in range(0, image.height, spacing_y):
        for x in range(0, image.width, spacing_x):
            draw.text((x, y), text, font=font, fill=fill_color)

    rotated = watermark.rotate(rotation_angle, expand=True)
    left = (rotated.width - image.width) // 2
    top = (rotated.height - image.height) // 2
    cropped = rotated.crop((left, top, left + image.width, top + image.height))
    return Image.alpha_composite(image.convert("RGBA"), cropped).convert("RGB")

def generate_quiz_text(row, question_number, show_answer):
    def safe_text(value):
        return str(value).strip() if pd.notna(value) else "Not Provided"

    question_text = safe_text(row.get('Question'))
    option_a = safe_text(row.get('Option A'))
    option_b = safe_text(row.get('Option B'))
    option_c = safe_text(row.get('Option C'))
    option_d = safe_text(row.get('Option D'))
    answer_text = safe_text(row.get('Answer')) if 'Answer' in row else "Not Provided"

    full_text = f"Q{question_number}. {question_text}\n\nA) {option_a}\nB) {option_b}\nC) {option_c}\nD) {option_d}"
    if show_answer:
        full_text += f"\n\nAnswer: {answer_text}"
    return full_text

def load_wallpapers(category_path):
    images = []
    if not os.path.exists(category_path):
        print(f"Warning: Wallpaper category path does not exist: {category_path}")
        return images
    for filename in os.listdir(category_path):
        if filename.lower().endswith(('.png', '.jpg', '.jpeg')):
            image_path = os.path.join(category_path, filename)
            image_cv = cv2.imread(image_path)
            if image_cv is None:
                print(f"Warning: Failed to load image: {image_path}")
                continue
            height, width = image_cv.shape[:2]
            crop_height = int(height * 0.95)
            cropped_image_cv = image_cv[0:crop_height, 0:width]
            cropped_image_pil = Image.fromarray(cv2.cvtColor(cropped_image_cv, cv2.COLOR_BGR2RGB))
            images.append(cropped_image_pil)
    print(f"Loaded {len(images)} wallpapers from {category_path}")
    return images

def create_poster(image, main_text, font_path, font_size, text_color, text_bg_color, canvas_size,
                  watermark_text, watermark_font_size, watermark_color, rotation_angle, opacity_percent):
    image = image.convert("RGBA").resize(canvas_size)
    draw = ImageDraw.Draw(image)
    font_main = ImageFont.truetype(font_path, font_size)
    max_text_width = image.width - 100
    wrapped_lines = wrap_text(main_text, font_main, max_text_width)
    total_text_height = sum([font_main.getbbox(line)[3] + 10 for line in wrapped_lines])
    text_start_y = (image.height - total_text_height) / 2
    draw_centered_text(draw, wrapped_lines, font_main, image.width, text_start_y, text_color, text_bg_color)
    image = add_watermark(image, watermark_text, font_path, watermark_font_size, watermark_color, rotation_angle, opacity_percent)
    return image.convert("RGB")

def create_dummy_poster():
    image = Image.new("RGB", (250, 312), color="#555")
    draw = ImageDraw.Draw(image)
    try:
        font = ImageFont.truetype("arial.ttf", 20)
    except:
        font = ImageFont.load_default()
    draw.text((50, 140), "Poster Placeholder", fill="#fff", font=font)
    return image

# --- Worker Thread for Poster Generation ---
class PosterWorker(QThread):
    progress = Signal(int)
    finished = Signal(list)
    error = Signal(str)
    preview = Signal(object)

    def __init__(self, poster_count, quiz_rows, wallpapers, font_path, font_size, text_color, text_bg_color, 
                 canvas_size, watermark_text, watermark_font_size, watermark_color, rotation_angle, 
                 opacity_percent, show_answer):
        super().__init__()
        self.poster_count = poster_count
        self.quiz_rows = quiz_rows
        self.wallpapers = wallpapers
        self.font_path = font_path
        self.font_size = font_size
        self.text_color = text_color
        self.text_bg_color = text_bg_color
        self.canvas_size = canvas_size
        self.watermark_text = watermark_text
        self.watermark_font_size = watermark_font_size
        self.watermark_color = watermark_color
        self.rotation_angle = rotation_angle
        self.opacity_percent = opacity_percent
        self.show_answer = show_answer

    def run(self):
        try:
            posters = []
            for idx, (row, wallpaper) in enumerate(zip(self.quiz_rows.iterrows(), self.wallpapers), start=1):
                _, quiz_row = row
                quiz_text = generate_quiz_text(quiz_row, idx, self.show_answer)
                poster_img = create_poster(
                    wallpaper.copy(), quiz_text, self.font_path, self.font_size, self.text_color, 
                    self.text_bg_color, self.canvas_size, self.watermark_text, self.watermark_font_size, 
                    self.watermark_color, self.rotation_angle, self.opacity_percent
                )
                posters.append(poster_img)
                self.progress.emit(int((idx / self.poster_count) * 100))
                if idx == 1:  # Send first poster for live preview
                    self.preview.emit(poster_img)
            self.finished.emit(posters)
        except Exception as e:
            self.error.emit(str(e))

# --- Preview Dialog ---
class PreviewDialog(QDialog):
    def __init__(self, image, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Poster Preview")
        layout = QVBoxLayout()
        self.image_label = QLabel()
        layout.addWidget(self.image_label)
        self.setLayout(layout)
        self.setStyleSheet("background-color: #2a2a2a; border-radius: 10px;")
        self.update_image(image)

    def update_image(self, image):
        buf = io.BytesIO()
        image.save(buf, format="PNG")
        qimage = QImage.fromData(buf.getvalue())
        pixmap = QPixmap.fromImage(qimage).scaled(600, 600, Qt.KeepAspectRatio)
        self.image_label.setPixmap(pixmap)

# --- Main Window ---
class QuizPosterApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(labels["app_title"])
        self.setGeometry(100, 100, 1400, 900)
        self.dark_mode = True  # Start in dark mode
        self.templates = {}  # Store saved templates
        self.wallpapers = []  # Initialize wallpapers as empty list

        # Load data
        self.all_sheets = pd.read_excel(CONFIG.get("sheet_url", ""), sheet_name=None)
        if not self.all_sheets:
            QMessageBox.warning(self, "Error", "No sheets found in the Excel file.")
            exit()

        self.subject_names = list(self.all_sheets.keys())
        self.wallpaper_categories = [name for name in os.listdir(WALLPAPER_FOLDER)
                                    if os.path.isdir(os.path.join(WALLPAPER_FOLDER, name))]
        if not self.wallpaper_categories:
            QMessageBox.warning(self, "Error", "No wallpaper categories found.")
            exit()

        # Initialize df_quiz with default subject
        self.df_quiz = self.all_sheets[self.subject_names[0]]  # Set default subject
        self.gallery = []
        self.num_columns = 3
        self.setup_ui()
        self.apply_theme()
        self.showMaximized()  # Start in full-screen mode

    def resizeEvent(self, event):
        super().resizeEvent(event)
        width = self.content_widget.width() if hasattr(self, 'content_widget') else 800
        self.num_columns = max(1, width // 280)
        if hasattr(self, 'gallery_layout'):
            self.update_gallery_layout()

    def update_gallery_layout(self):
        # Re-layout the gallery based on current num_columns
        items = [self.gallery_layout.itemAt(i).widget() for i in range(self.gallery_layout.count())]
        for i in reversed(range(self.gallery_layout.count())):
            self.gallery_layout.itemAt(i).widget().setParent(None)
        for idx, widget in enumerate(items):
            row = idx // (2 * self.num_columns)
            col = (idx % (2 * self.num_columns)) % self.num_columns
            sub_row = idx % 2  # 0 for caption, 1 for image
            self.gallery_layout.addWidget(widget, row * 2 + sub_row, col)

    def apply_theme(self):
        palette = QPalette()
        if self.dark_mode:
            palette.setColor(QPalette.Window, QColor(30, 30, 30))
            palette.setColor(QPalette.WindowText, Qt.white)
            palette.setColor(QPalette.Base, QColor(45, 45, 45))
            palette.setColor(QPalette.Button, QColor(60, 60, 60))
            palette.setColor(QPalette.ButtonText, Qt.white)
            palette.setColor(QPalette.Text, Qt.white)
            palette.setColor(QPalette.Highlight, QColor(0, 120, 212))
        else:
            palette.setColor(QPalette.Window, Qt.white)
            palette.setColor(QPalette.WindowText, Qt.black)
            palette.setColor(QPalette.Base, Qt.white)
            palette.setColor(QPalette.Button, QColor(240, 240, 240))
            palette.setColor(QPalette.ButtonText, Qt.black)
            palette.setColor(QPalette.Text, Qt.black)
            palette.setColor(QPalette.Highlight, QColor(0, 120, 212))
        self.setPalette(palette)
        self.setStyleSheet("""
            QMainWindow { background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #2a2a2a, stop:1 #3c3c3c); }
            QGroupBox { font-weight: bold; border: 1px solid #555; border-radius: 8px; padding: 10px; background-color: #333; }
            QLabel { color: #fff; font-size: 14px; }
            QComboBox { background-color: #444; color: #fff; border: 1px solid #555; border-radius: 5px; padding: 5px; }
            QComboBox:hover { background-color: #555; }
            QSlider::groove:horizontal { background: #555; height: 8px; border-radius: 4px; }
            QSlider::handle:horizontal { background: #0078d4; width: 16px; border-radius: 8px; }
            QCheckBox { color: #fff; }
            QPushButton { background-color: #0078d4; color: #fff; border-radius: 5px; padding: 8px; margin-top:100px; }
            QPushButton:hover { background-color: #005ba1; }
            QTextEdit { background-color: #444; color: #fff; border: 1px solid #555; border-radius: 5px; }
            QProgressBar { background-color: #444; border: 1px solid #555; border-radius: 5px; color: #fff; }
            QProgressBar::chunk { background-color: #0078d4; border-radius: 5px; }
            QTabWidget::pane { border: 1px solid #555; background: #333; }
            QTabBar::tab { background: #444; color: #fff; padding: 8px; border-radius: 5px; }
            QTabBar::tab:selected { background: #0078d4; }
            QScrollArea { background-color: #333; border: none; }
        """)

    def setup_ui(self):
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QHBoxLayout(central_widget)

        # Sidebar with Scroll Area
        sidebar = QGroupBox(labels["app_title"])
        sidebar.setFixedWidth(400)
        sidebar_layout = QVBoxLayout()
        sidebar_scroll = QScrollArea()
        sidebar_scroll.setWidgetResizable(True)
        sidebar_container = QWidget()
        sidebar_container_layout = QVBoxLayout(sidebar_container)

        # Tabs for Settings
        tabs = QTabWidget()
        tabs.setTabPosition(QTabWidget.North)

        # Tab 1: General Settings
        general_tab = QWidget()
        general_layout = QVBoxLayout()
        self.dark_mode_toggle = QCheckBox("Dark Mode")
        self.dark_mode_toggle.setChecked(True)
        self.dark_mode_toggle.stateChanged.connect(self.toggle_theme)
        self.dark_mode_toggle.setToolTip("Toggle dark/light mode")
        general_layout.addWidget(self.dark_mode_toggle)
        self.wallpaper_combo = QComboBox()
        self.wallpaper_combo.addItems(self.wallpaper_categories)
        self.wallpaper_combo.currentTextChanged.connect(self.load_wallpapers)
        self.wallpaper_combo.setToolTip("Select a wallpaper category")
        general_layout.addWidget(QLabel(labels["wallpaper_category"]))
        general_layout.addWidget(self.wallpaper_combo)
        self.subject_combo = QComboBox()
        self.subject_combo.addItems(self.subject_names)
        self.subject_combo.currentTextChanged.connect(self.update_topics)
        self.subject_combo.setToolTip("Select a subject")
        general_layout.addWidget(QLabel(labels["subject"]))
        general_layout.addWidget(self.subject_combo)
        self.topic_combo = QComboBox()
        self.topic_combo.setToolTip("Select a topic")
        general_layout.addWidget(QLabel(labels["topic"]))
        general_layout.addWidget(self.topic_combo)
        self.platform_combo = QComboBox()
        self.platform_combo.addItems(list(PLATFORM_DIMENSIONS.keys()))
        self.platform_combo.setToolTip("Select poster dimensions")
        general_layout.addWidget(QLabel(labels["poster_format"]))
        general_layout.addWidget(self.platform_combo)
        self.poster_count_slider = QSlider(Qt.Horizontal)
        self.poster_count_slider.setRange(1, 200)
        self.poster_count_slider.setValue(defaults["poster_count"])
        self.poster_count_slider.setToolTip("Number of posters to generate")
        general_layout.addWidget(QLabel(labels["poster_count"]))
        general_layout.addWidget(self.poster_count_slider)
        self.question_mode_combo = QComboBox()
        self.question_mode_combo.addItems(labels["question_mode_options"])
        self.question_mode_combo.setCurrentText(defaults["question_mode"])
        self.question_mode_combo.setToolTip("Select question display mode")
        general_layout.addWidget(QLabel(labels["question_mode"]))
        general_layout.addWidget(self.question_mode_combo)
        general_tab.setLayout(general_layout)
        tabs.addTab(general_tab, "General")

        # Tab 2: Text Settings
        text_tab = QWidget()
        text_layout = QVBoxLayout()
        self.font_combo = QComboBox()
        self.font_combo.addItems(list(FONT_OPTIONS.keys()))
        self.font_combo.currentTextChanged.connect(self.update_preview)
        self.font_combo.setToolTip("Select font for poster text")
        text_layout.addWidget(QLabel(labels["font"]))
        text_layout.addWidget(self.font_combo)
        self.font_size_slider = QSlider(Qt.Horizontal)
        self.font_size_slider.setRange(20, 100)
        self.font_size_slider.setValue(defaults["font_size"])
        self.font_size_slider.valueChanged.connect(self.update_preview)
        self.font_size_slider.setToolTip("Adjust font size")
        text_layout.addWidget(QLabel(labels["font_size"]))
        text_layout.addWidget(self.font_size_slider)
        self.text_color_button = QPushButton("Pick Text Color")
        self.text_color_button.clicked.connect(self.pick_text_color)
        self.text_color = defaults["text_color"]
        self.text_color_button.setToolTip("Choose text color")
        text_layout.addWidget(QLabel(labels["text_color"]))
        text_layout.addWidget(self.text_color_button)
        self.bg_transparent = QCheckBox(labels["bg_transparent"])
        self.bg_transparent.setChecked(defaults["bg_transparent"])
        self.bg_transparent.stateChanged.connect(self.toggle_bg_color)
        self.bg_transparent.setToolTip("Toggle transparent text background")
        text_layout.addWidget(self.bg_transparent)
        self.text_bg_color_button = QPushButton("Pick Background Color")
        self.text_bg_color_button.clicked.connect(self.pick_text_bg_color)
        self.text_bg_color = defaults["text_bg_color"] if not defaults["bg_transparent"] else None
        self.text_bg_color_button.setToolTip("Choose text background color")
        text_layout.addWidget(QLabel(labels["text_bg_color"]))
        text_layout.addWidget(self.text_bg_color_button)
        self.text_bg_color_button.setEnabled(not defaults["bg_transparent"])
        self.show_answer = QCheckBox(labels["show_answer"])
        self.show_answer.setChecked(defaults["show_answer"])
        self.show_answer.stateChanged.connect(self.update_preview)
        self.show_answer.setToolTip("Show answer on posters")
        text_layout.addWidget(self.show_answer)
        text_tab.setLayout(text_layout)
        tabs.addTab(text_tab, "Text Settings")

        # Tab 3: Watermark Settings
        watermark_tab = QWidget()
        watermark_layout = QVBoxLayout()
        self.watermark_text = QTextEdit()
        self.watermark_text.setText(watermark_defaults["text"])
        self.watermark_text.textChanged.connect(self.update_preview)
        self.watermark_text.setToolTip("Enter watermark text")
        watermark_layout.addWidget(QLabel(labels["watermark_text"]))
        watermark_layout.addWidget(self.watermark_text)
        self.watermark_font_size = QSlider(Qt.Horizontal)
        self.watermark_font_size.setRange(20, 80)
        self.watermark_font_size.setValue(watermark_defaults["font_size"])
        self.watermark_font_size.valueChanged.connect(self.update_preview)
        self.watermark_font_size.setToolTip("Adjust watermark font size")
        watermark_layout.addWidget(QLabel(labels["watermark_font_size"]))
        watermark_layout.addWidget(self.watermark_font_size)
        self.watermark_color_button = QPushButton("Pick Watermark Color")
        self.watermark_color_button.clicked.connect(self.pick_watermark_color)
        self.watermark_color = watermark_defaults["color"]
        self.watermark_color_button.setToolTip("Choose watermark color")
        watermark_layout.addWidget(QLabel(labels["watermark_color"]))
        watermark_layout.addWidget(self.watermark_color_button)
        self.watermark_rotation = QSlider(Qt.Horizontal)
        self.watermark_rotation.setRange(0, 180)
        self.watermark_rotation.setValue(watermark_defaults["rotation"])
        self.watermark_rotation.valueChanged.connect(self.update_preview)
        self.watermark_rotation.setToolTip("Adjust watermark rotation")
        watermark_layout.addWidget(QLabel(labels["watermark_rotation"]))
        watermark_layout.addWidget(self.watermark_rotation)
        self.watermark_opacity = QSlider(Qt.Horizontal)
        self.watermark_opacity.setRange(5, 50)
        self.watermark_opacity.setValue(watermark_defaults["opacity"])
        self.watermark_opacity.valueChanged.connect(self.update_preview)
        self.watermark_opacity.setToolTip("Adjust watermark opacity")
        watermark_layout.addWidget(QLabel(labels["watermark_opacity"]))
        watermark_layout.addWidget(self.watermark_opacity)
        watermark_tab.setLayout(watermark_layout)
        tabs.addTab(watermark_tab, "Watermark")

        # Tab 4: Templates & Output
        template_output_tab = QWidget()
        template_output_layout = QVBoxLayout()
        template_layout = QHBoxLayout()
        self.save_template_button = QPushButton("Save Template")
        self.save_template_button.clicked.connect(self.save_template)
        self.save_template_button.setToolTip("Save current settings as a template")
        self.load_template_combo = QComboBox()
        self.load_template_combo.currentTextChanged.connect(self.load_template)
        self.load_template_combo.setToolTip("Load a saved template")
        template_layout.addWidget(self.save_template_button)
        template_layout.addWidget(self.load_template_combo)
        template_output_layout.addWidget(QLabel("Templates"))
        template_output_layout.addLayout(template_layout)
        self.output_format_combo = QComboBox()
        self.output_format_combo.addItems(labels["output_format_options"])
        self.output_format_combo.setCurrentText(defaults["output_format"])
        self.output_format_combo.setToolTip("Select output format")
        template_output_layout.addWidget(QLabel(labels["output_format"]))
        template_output_layout.addWidget(self.output_format_combo)
        template_output_tab.setLayout(template_output_layout)
        tabs.addTab(template_output_tab, "Templates & Output")

        # Generate Button
        self.generate_button = QPushButton(labels["generate_button"])
        self.generate_button.clicked.connect(self.generate_posters)
        self.generate_button.setToolTip("Generate posters with current settings")

        sidebar_container_layout.addWidget(tabs)
        sidebar_container_layout.addWidget(self.generate_button)
        sidebar_container_layout.addStretch()
        sidebar_scroll.setWidget(sidebar_container)
        sidebar_layout.addWidget(sidebar_scroll)
        sidebar.setLayout(sidebar_layout)
        main_layout.addWidget(sidebar)

        # Main Content (Right Panel)
        self.content_widget = QWidget()
        self.content_layout = QVBoxLayout()
        self.content_widget.setLayout(self.content_layout)
        main_layout.addWidget(self.content_widget)

        # Initial Preview Area
        self.show_preview_area()

    def show_preview_area(self):
        # Clear content layout safely
        for i in reversed(range(self.content_layout.count())):
            item = self.content_layout.itemAt(i)
            if item and item.widget():
                print(f"Removing widget at index {i}: {item.widget()}")
                item.widget().setParent(None)
            # Optionally remove spacers or other items if needed
            # elif item:  # Uncomment and handle other item types if required
            #     self.content_layout.removeItem(item)

        # Preview Area
        self.preview_label = QLabel("Live Preview")
        self.preview_label.setAlignment(Qt.AlignCenter)
        self.preview_label.setStyleSheet("font-size: 16px; font-weight: bold; color: #fff;")
        self.preview_image = QLabel()
        self.preview_image.setAlignment(Qt.AlignCenter)
        self.preview_image.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.preview_image.setStyleSheet("border: 1px solid #555; border-radius: 8px; background-color: #444; padding: 10px;")
        self.content_layout.addWidget(self.preview_label)
        self.content_layout.addWidget(self.preview_image, 1)  # Stretch to fill space
        self.update_preview()

        # Add dummy gallery cards
        self.gallery_scroll = QScrollArea()
        self.gallery_scroll.setWidgetResizable(True)
        self.gallery_container = QWidget()
        self.gallery_layout = QGridLayout()
        self.gallery_container.setLayout(self.gallery_layout)
        self.gallery_scroll.setWidget(self.gallery_container)
        self.content_layout.addWidget(self.gallery_scroll, 1)  # Stretch to fill space

        # Add 6 dummy cards
        for idx in range(6):
            dummy_img = create_dummy_poster()
            buf = io.BytesIO()
            dummy_img.save(buf, format="PNG")
            qimage = QImage.fromData(buf.getvalue())
            pixmap = QPixmap.fromImage(qimage)
            label = QLabel()
            label.setPixmap(pixmap)
            label.setStyleSheet("QLabel { border: 1px solid #555; border-radius: 5px; background-color: #444; } QLabel:hover { border: 2px solid #0078d4; }")
            caption = QLabel(f"Placeholder {idx+1}")
            caption.setStyleSheet("color: #fff; font-size: 12px; text-align: center;")
            row = idx // self.num_columns
            col = idx % self.num_columns
            self.gallery_layout.addWidget(caption, row * 2, col)
            self.gallery_layout.addWidget(label, row * 2 + 1, col)

    def toggle_theme(self):
        self.dark_mode = self.dark_mode_toggle.isChecked()
        self.apply_theme()

    def load_wallpapers(self, category):
        self.wallpapers = load_wallpapers(os.path.join(WALLPAPER_FOLDER, category))
        if not self.wallpapers:
            QMessageBox.warning(self, "Error", f"No valid wallpaper images found in {category}.")
            self.generate_button.setEnabled(False)
        else:
            self.generate_button.setEnabled(True)
            random.shuffle(self.wallpapers)
            self.update_preview()

    def update_topics(self, subject):
        self.topic_combo.clear()
        self.df_quiz = self.all_sheets[subject]
        if "Topic" not in self.df_quiz.columns:
            QMessageBox.warning(self, "Error", "'Topic' column missing in selected sheet.")
            self.generate_button.setEnabled(False)
            return
        unique_topics = sorted(self.df_quiz['Topic'].dropna().unique())
        self.topic_combo.addItems(unique_topics)
        self.update_poster_count_limit()
        self.update_preview()

    def update_poster_count_limit(self):
        selected_topic = self.topic_combo.currentText()
        if not selected_topic:
            self.poster_count_slider.setMaximum(1)
            return
        filtered_df = self.df_quiz[self.df_quiz['Topic'] == selected_topic]
        max_posters = min(200, len(filtered_df))
        self.poster_count_slider.setMaximum(max_posters)
        self.poster_count_slider.setValue(min(defaults["poster_count"], max_posters))

    def pick_text_color(self):
        color = QColorDialog.getColor()
        if color.isValid():
            self.text_color = color.name()
            self.update_preview()

    def pick_text_bg_color(self):
        color = QColorDialog.getColor()
        if color.isValid():
            self.text_bg_color = color.name()
            self.update_preview()

    def pick_watermark_color(self):
        color = QColorDialog.getColor()
        if color.isValid():
            self.watermark_color = color.name()
            self.update_preview()

    def toggle_bg_color(self):
        self.text_bg_color_button.setEnabled(not self.bg_transparent.isChecked())
        self.text_bg_color = None if self.bg_transparent.isChecked() else defaults["text_bg_color"]
        self.update_preview()

    def update_preview(self):
        if not hasattr(self, 'wallpapers') or not self.wallpapers or not hasattr(self, 'df_quiz'):
            self.preview_image.clear()
            return
        selected_topic = self.topic_combo.currentText()
        if not selected_topic:
            self.preview_image.clear()
            return
        filtered_df = self.df_quiz[self.df_quiz['Topic'] == selected_topic]
        if filtered_df.empty:
            self.preview_image.clear()
            return
        quiz_row = filtered_df.iloc[0]
        quiz_text = generate_quiz_text(quiz_row, 1, self.show_answer.isChecked())
        canvas_size = PLATFORM_DIMENSIONS[self.platform_combo.currentText()]
        font_path = FONT_OPTIONS[self.font_combo.currentText()]
        try:
            preview_img = create_poster(
                self.wallpapers[0].copy(), quiz_text, font_path, self.font_size_slider.value(),
                self.text_color, self.text_bg_color, canvas_size, self.watermark_text.toPlainText(),
                self.watermark_font_size.value(), self.watermark_color, self.watermark_rotation.value(),
                self.watermark_opacity.value()
            )
            buf = io.BytesIO()
            preview_img.save(buf, format="PNG")
            qimage = QImage.fromData(buf.getvalue())
            pixmap = QPixmap.fromImage(qimage).scaled(self.preview_image.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.preview_image.setPixmap(pixmap)
            # Fade-in animation
            anim = QPropertyAnimation(self.preview_image, b"windowOpacity")
            anim.setDuration(500)
            anim.setStartValue(0)
            anim.setEndValue(1)
            anim.setEasingCurve(QEasingCurve.InOutQuad)
            anim.start()
        except Exception as e:
            self.preview_image.clear()
            QMessageBox.warning(self, "Preview Error", f"Failed to generate preview: {e}")

    def save_template(self):
        template_name = f"template_{len(self.templates) + 1}"
        template = {
            "font": self.font_combo.currentText(),
            "font_size": self.font_size_slider.value(),
            "text_color": self.text_color,
            "text_bg_color": self.text_bg_color,
            "bg_transparent": self.bg_transparent.isChecked(),
            "show_answer": self.show_answer.isChecked(),
            "watermark_text": self.watermark_text.toPlainText(),
            "watermark_font_size": self.watermark_font_size.value(),
            "watermark_color": self.watermark_color,
            "watermark_rotation": self.watermark_rotation.value(),
            "watermark_opacity": self.watermark_opacity.value(),
            "platform": self.platform_combo.currentText(),
            "question_mode": self.question_mode_combo.currentText(),
            "output_format": self.output_format_combo.currentText()
        }
        self.templates[template_name] = template
        self.load_template_combo.addItem(template_name)
        with open(os.path.join(BASE_DIR, "templates.json"), "w") as f:
            json.dump(self.templates, f)
        QMessageBox.information(self, "Success", f"Template '{template_name}' saved.")

    def load_template(self, template_name):
        if template_name in self.templates:
            template = self.templates[template_name]
            self.font_combo.setCurrentText(template["font"])
            self.font_size_slider.setValue(template["font_size"])
            self.text_color = template["text_color"]
            self.text_bg_color = template["text_bg_color"]
            self.bg_transparent.setChecked(template["bg_transparent"])
            self.show_answer.setChecked(template["show_answer"])
            self.watermark_text.setText(template["watermark_text"])
            self.watermark_font_size.setValue(template["watermark_font_size"])
            self.watermark_color = template["watermark_color"]
            self.watermark_rotation.setValue(template["watermark_rotation"])
            self.watermark_opacity.setValue(template["watermark_opacity"])
            self.platform_combo.setCurrentText(template["platform"])
            self.question_mode_combo.setCurrentText(template["question_mode"])
            self.output_format_combo.setCurrentText(template["output_format"])
            self.update_preview()

    def generate_posters(self):
        selected_topic = self.topic_combo.currentText()
        filtered_df = self.df_quiz[self.df_quiz['Topic'] == selected_topic]
        if filtered_df.empty:
            QMessageBox.warning(self, "Error", "No quiz data found for selected topic.")
            return

        if not self.wallpapers or len(self.wallpapers) == 0:
            QMessageBox.warning(self, "Error", "No wallpapers loaded. Please select a valid wallpaper category.")
            self.generate_button.setEnabled(False)
            return

        poster_count = self.poster_count_slider.value()
        canvas_size = PLATFORM_DIMENSIONS[self.platform_combo.currentText()]
        font_path = FONT_OPTIONS[self.font_combo.currentText()]
        quiz_rows = filtered_df.sample(n=poster_count) if self.question_mode_combo.currentText() == "Random" else filtered_df.iloc[:poster_count]
        wallpapers_to_use = list(islice(cycle(self.wallpapers), poster_count))

        self.worker = PosterWorker(
            poster_count, quiz_rows, wallpapers_to_use, font_path, self.font_size_slider.value(),
            self.text_color, self.text_bg_color, canvas_size, self.watermark_text.toPlainText(),
            self.watermark_font_size.value(), self.watermark_color, self.watermark_rotation.value(),
            self.watermark_opacity.value(), self.show_answer.isChecked()
        )
        self.worker.progress.connect(self.update_progress)
        self.worker.finished.connect(self.display_posters)
        self.worker.error.connect(self.show_error)
        self.worker.preview.connect(self.show_preview)
        self.worker.start()
        self.generate_button.setEnabled(False)


    def download_question_paper(self):
        if not hasattr(self, 'df_quiz') or self.df_quiz.empty:
            QMessageBox.warning(self, "Error", "No questions available to download.")
            return
        
        selected_topic = self.topic_combo.currentText()
        filtered_df = self.df_quiz[self.df_quiz['Topic'] == selected_topic]
        if filtered_df.empty:
            QMessageBox.warning(self, "Error", "No questions found for selected topic.")
            return

        file_path, _ = QFileDialog.getSaveFileName(
            self, "Save Question Paper", f"{selected_topic}_Question_Paper.pdf", "PDF Files (*.pdf)"
        )
        if not file_path:
            return

        try:
            from reportlab.lib.pagesizes import A4
            from reportlab.pdfgen import canvas
            from reportlab.lib.units import cm

            c = canvas.Canvas(file_path, pagesize=A4)
            width, height = A4

            # Title
            c.setFont("Helvetica-Bold", 14)
            c.drawCentredString(width / 2.0, height - 1.5 * cm, f"Question Paper - {selected_topic}")

            # Margins & column setup
            margin_left = 2 * cm
            margin_top = 2.5 * cm
            col_gap = 1 * cm
            col_width = (width - 2 * margin_left - col_gap) / 2

            x_positions = [margin_left, margin_left + col_width + col_gap]  # Left col, Right col
            col_index = 0  # Start with left column
            y = height - margin_top
            question_number = 1

            c.setFont("Helvetica", 11)
            line_height = 14

            for _, row in filtered_df.iterrows():
                question_text = str(row.get("Question", "Not Provided")).strip()
                option_a = str(row.get("Option A", "")).strip()
                option_b = str(row.get("Option B", "")).strip()
                option_c = str(row.get("Option C", "")).strip()
                option_d = str(row.get("Option D", "")).strip()

                block = [
                    f"Q{question_number}. {question_text}",
                    f"   A) {option_a}",
                    f"   B) {option_b}",
                    f"   C) {option_c}",
                    f"   D) {option_d}"
                ]

                # Draw wrapped lines
                for line in block:
                    while len(line) > 80:  # wrap long lines to fit column
                        part = line[:80]
                        line = line[80:]
                        if y <= 2 * cm:  # End of column
                            if col_index == 0:  # shift to right column
                                col_index = 1
                                y = height - margin_top
                            else:  # both columns full â†’ new page
                                c.showPage()
                                c.setFont("Helvetica", 11)
                                col_index = 0
                                y = height - margin_top
                        c.drawString(x_positions[col_index], y, part)
                        y -= line_height

                    if y <= 2 * cm:  # End of column
                        if col_index == 0:
                            col_index = 1
                            y = height - margin_top
                        else:
                            c.showPage()
                            c.setFont("Helvetica", 11)
                            col_index = 0
                            y = height - margin_top

                    c.drawString(x_positions[col_index], y, line)
                    y -= line_height

                question_number += 1
                y -= 8  # gap between questions

            c.save()
            QMessageBox.information(self, "Success", "Question paper saved successfully.")

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to generate question paper: {e}")


    def update_progress(self, value):
        if not hasattr(self, 'progress_bar'):
            self.progress_bar = QProgressBar()
            self.content_layout.insertWidget(self.content_layout.count() - 1, self.progress_bar)
        self.progress_bar.setValue(value)

    def show_preview(self, image):
        self.preview_dialog = PreviewDialog(image, self)
        self.preview_dialog.show()
        anim = QPropertyAnimation(self.preview_dialog, b"windowOpacity")
        anim.setDuration(500)
        anim.setStartValue(0)
        anim.setEndValue(1)
        anim.setEasingCurve(QEasingCurve.InOutQuad)
        anim.start()

    def display_posters(self, posters):
        self.gallery = posters
        # Clear content layout
        for i in reversed(range(self.content_layout.count())):
            item = self.content_layout.itemAt(i)
            if item and item.widget():
                print(f"Removing widget at index {i}: {item.widget()}")
                item.widget().setParent(None)
            # Optionally remove spacers or other items if needed
            # elif item:  # Uncomment and handle other item types if required
            #     self.content_layout.removeItem(item)

        # Add progress bar and download buttons
        self.progress_bar = QProgressBar()
        self.content_layout.addWidget(self.progress_bar)
        self.progress_bar.setValue(100)

        download_layout = QHBoxLayout()
        back_button = QPushButton("Back to Preview")
        back_button.clicked.connect(self.show_preview_area)
        download_layout.addWidget(back_button)
        self.download_zip_button = QPushButton("Download ZIP")
        self.download_zip_button.clicked.connect(self.download_zip)
        self.download_zip_button.setToolTip("Download posters as ZIP")
        self.download_pdf_button = QPushButton("Generate PDF")
        self.download_pdf_button.clicked.connect(self.download_pdf)
        self.download_pdf_button.setToolTip("Download posters as PDF")
        download_layout.addWidget(self.download_zip_button)
        download_layout.addWidget(self.download_pdf_button)
        self.content_layout.addLayout(download_layout)

        self.download_question_paper_button = QPushButton("Download Question Paper")
        self.download_question_paper_button.clicked.connect(self.download_question_paper)
        self.download_question_paper_button.setToolTip("Download all questions in A4 sheet format")
        download_layout.addWidget(self.download_question_paper_button)


        # Add gallery
        self.gallery_scroll = QScrollArea()
        self.gallery_scroll.setWidgetResizable(True)
        self.gallery_container = QWidget()
        self.gallery_layout = QGridLayout()
        self.gallery_container.setLayout(self.gallery_layout)
        self.gallery_scroll.setWidget(self.gallery_container)
        self.content_layout.addWidget(self.gallery_scroll, 1)

        for idx, img in enumerate(posters):
            buf = io.BytesIO()
            img.save(buf, format="PNG")
            qimage = QImage.fromData(buf.getvalue())
            pixmap = QPixmap.fromImage(qimage).scaled(250, 312, Qt.KeepAspectRatio)
            label = QLabel()
            label.setPixmap(pixmap)
            label.mousePressEvent = lambda event, idx=idx: self.show_full_poster(idx)
            label.setStyleSheet("QLabel { border: 1px solid #555; border-radius: 5px; background-color: #444; } QLabel:hover { border: 2px solid #0078d4; }")
            caption = QLabel(f"Poster {idx+1}")
            caption.setStyleSheet("color: #fff; font-size: 12px; text-align: center;")
            row = idx // self.num_columns
            col = idx % self.num_columns
            self.gallery_layout.addWidget(caption, row * 2, col)
            self.gallery_layout.addWidget(label, row * 2 + 1, col)
            # Fade-in animation
            anim = QPropertyAnimation(label, b"windowOpacity")
            anim.setDuration(500)
            anim.setStartValue(0)
            anim.setEndValue(1)
            anim.setEasingCurve(QEasingCurve.InOutQuad)
            anim.start()
        
        self.generate_button.setEnabled(True)
        self.download_zip_button.setEnabled(True)
        self.download_pdf_button.setEnabled(True)

    def show_full_poster(self, idx):
        dialog = PreviewDialog(self.gallery[idx], self)
        dialog.show()
        anim = QPropertyAnimation(dialog, b"windowOpacity")
        anim.setDuration(500)
        anim.setStartValue(0)
        anim.setEndValue(1)
        anim.setEasingCurve(QEasingCurve.InOutQuad)
        anim.start()

    def show_error(self, message):
        QMessageBox.critical(self, "Error", f"Failed to generate posters: {message}")
        self.generate_button.setEnabled(True)

    def download_zip(self):
        if not self.gallery:
            QMessageBox.warning(self, "Error", "No posters to download.")
            return
        file_path, _ = QFileDialog.getSaveFileName(self, "Save ZIP", f"{self.topic_combo.currentText()}_Quiz_Posters.zip", "ZIP Files (*.zip)")
        if file_path:
            zip_buffer = io.BytesIO()
            with zipfile.ZipFile(zip_buffer, "a", zipfile.ZIP_DEFLATED) as zipf:
                for idx, img in enumerate(self.gallery, start=1):
                    buf = io.BytesIO()
                    ext = "PNG" if self.output_format_combo.currentText() == "PNG" else "JPEG"
                    img.save(buf, format=ext)
                    zipf.writestr(f"{self.topic_combo.currentText()}_poster_{idx}.{ext.lower()}", buf.getvalue())
            with open(file_path, "wb") as f:
                f.write(zip_buffer.getvalue())
            QMessageBox.information(self, "Success", "ZIP file saved successfully.")

    def download_pdf(self):
        if not self.gallery:
            QMessageBox.warning(self, "Error", "No posters to download.")
            return
        file_path, _ = QFileDialog.getSaveFileName(self, "Save PDF", f"{self.topic_combo.currentText()}_Quiz_Posters.pdf", "PDF Files (*.pdf)")
        if file_path:
            pdf_buffer = io.BytesIO()
            self.gallery[0].save(pdf_buffer, format="PDF", save_all=True, append_images=self.gallery[1:])
            with open(file_path, "wb") as f:
                f.write(pdf_buffer.getvalue())
            QMessageBox.information(self, "Success", "PDF file saved successfully.")

if __name__ == "__main__":
    from PySide6.QtWidgets import QApplication
    import sys
    app = QApplication(sys.argv)
    app.setStyle("Fusion")
    app.setFont(QFont("Segoe UI", 10))
    window = QuizPosterApp()
    window.show()
    sys.exit(app.exec())